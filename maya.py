# -*- coding: utf-8 -*-
"""MAYA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pSSq6gEQyQvMQAzA_cb4bqXl5zRZtq68
"""

def chemical_multiverse(dataset=None, ID=None, smiles_column_name=None, target_activities=[None], vPCA=True, t_SNE=True, MACCS=True, ECFP=True, MD=True, palette=['#8A82FF', "#B49CFF", "#FF69A0", "#FF83B3", '#FFC28A'], perplexity=33):

   file_readers = {
    'csv': pd.read_csv,
    'xlsx': pd.read_excel,
    'tsv': lambda f: pd.read_csv(f, delimiter='\t'),
    'json': pd.read_json,
    'xml': pd.read_xml}

   ext = dataset.split('.')[-1]

   if ext not in file_readers:
      raise ValueError("Formato de archivo no soportado")
   input_df = file_readers[ext](dataset)
   required_columns = [dataset, ID, smiles_column_name, target_activities]
   if any(col is None for col in required_columns):
       raise ValueError("Se deben especificar el nombre del archivo y las columnas de SMILES, ID y actividades objetivo.")

   STD = Standardizer()
   LFC = LargestFragmentChooser()
   UC = Uncharger()
   RI = Reionizer()
   TC = TautomerCanonicalizer()

   def pretreatment(smi):
        try:
            mol = Chem.MolFromSmiles(smi)
            if mol is None:
                return "Error 1"
            mol = STD(mol)
            mol = LFC(mol)
            allowed_elements = {"H","B","C","N","O","F","Si","P","S","Cl","Se","Br","I"}
            actual_elements = set([atom.GetSymbol() for atom in mol.GetAtoms()])
            if len(actual_elements-allowed_elements) == 0:
                mol = UC(mol)
                mol = RI(mol)
                mol = TC(mol)
                return Chem.MolToSmiles(mol)
            else:
                return "Error 2"
        except Exception as e:
            return f'Something else was found'

   input_df["Canonical Smiles"] = input_df[smiles_column_name].apply(pretreatment)
   input_df = input_df[~input_df["Canonical Smiles"].isin(["Error 1", "Error 2", "Error general"])].reset_index(drop=True)

   for activity_target in target_activities:
      input_df['Activity Index'] = -np.log(input_df[target_activities]).mean(axis=1)
      input_df['std'] = input_df[target_activities].std(axis=1)
      input_df['norma'] = ((input_df['std'] - input_df['std'].min()) / (input_df['std'].max() - input_df['std'].min()))
      input_df['normal_desviation'] = input_df['norma'] * (12-7)+5
      input_df['normal_desviation'].fillna(7, inplace=True)

   def similarity_calc(smi1, smi2, method='tanimoto', fp_type='MACCS'):
        mol1 = Chem.MolFromSmiles(smi1)
        mol2 = Chem.MolFromSmiles(smi2)

        if fp_type == 'MACCS':
            fp1 = MACCSkeys.GenMACCSKeys(mol1)
            fp2 = MACCSkeys.GenMACCSKeys(mol2)
        elif fp_type == 'ECFP':
            fp1 = AllChem.GetMorganFingerprintAsBitVect(mol1, 3, nBits=2048)
            fp2 = AllChem.GetMorganFingerprintAsBitVect(mol2, 3, nBits=2048)

        if method == 'tanimoto':
            similarity = round(DataStructs.TanimotoSimilarity(fp1, fp2), 3)
        elif method == 'dice':
            similarity = round(DataStructs.DiceSimilarity(fp1, fp2), 3)
        elif method == 'cosine':
            similarity = round(DataStructs.CosineSimilarity(fp1, fp2), 3)
        elif method == 'euclidean':
            similarity = round(np.linalg.norm(fp1 - fp2), 3)
        else:
            raise ValueError("MÃ©todo no reconocido. Usa 'tanimoto', 'dice', 'cosine', o 'euclidean'.")
        return similarity

   def configure_plot_layout(fig, data_frame):
      fig.update_layout(
          plot_bgcolor='white',
          paper_bgcolor='white',
          xaxis=dict(
              showgrid=True,
              gridcolor='lightgrey',
              gridwidth=0.5,
              griddash='dot',
              zerolinecolor='lightgrey',),
          yaxis=dict(
              showgrid=True,
              gridcolor='lightgrey',
              gridwidth=0.5,
              griddash='dot',
              zerolinecolor='lightgrey',))
      fig.update_traces(
          marker=dict(
              size=input_df['normal_desviation'],
              symbol='circle',
              line=dict(
                  width=1,
                  color='DarkSlateGrey')))
      app_maker = molplotly.add_molecules(
          fig=fig,
          df=data_frame,
          smiles_col=smiles_column_name,
          title_col=smiles_column_name,
          color_col='Activity Index')
      return fig
   if MACCS is True:
              matrix_values=np.zeros((len(input_df), len(input_df)))

              for i in input_df.index:
                  for j in input_df.index:
                          a=input_df.loc[i].at['Canonical Smiles']
                          b=input_df.loc[j].at['Canonical Smiles']
                          alignment= similarity_calc(a,b, 'tanimoto', fp_type='MACCS')
                          matrix_values[i,j]=alignment
              matrix_MACCS = pd.DataFrame(matrix_values, index=input_df[ID], columns=input_df[ID])
              df_MACCS = pd.DataFrame(matrix_MACCS)
              if vPCA is True:
                    data_MACCS = matrix_MACCS.iloc[:,0:].values
                    pd.DataFrame(data_MACCS)
                    label_MACCS = input_df.iloc[:,0].values
                    pca_MACCS = PCA(n_components=2)
                    pca_results_MACCS = pca_MACCS.fit_transform(data_MACCS)
                    label_MACCS = input_df[[ID, smiles_column_name]]
                    label_MACCS = label_MACCS.to_numpy()
                    arr = np.concatenate((label_MACCS,pca_results_MACCS), axis = 1)
                    data_MACCS_PCA = pd.DataFrame(data=arr, columns = [ID, smiles_column_name, 'component1', 'component2'])
                    pca = PCA()
                    X_train_pca = pca.fit_transform(data_MACCS)
                    exp_var_pca = pca.explained_variance_ratio_
                    cum_sum_eigenvalues = np.cumsum(exp_var_pca)
                    plt.bar(range(0,len(exp_var_pca)), exp_var_pca, alpha=0.5, align='center', label='Individual explained variance')
                    plt.step(range(0,len(cum_sum_eigenvalues)), cum_sum_eigenvalues, where='mid',label='Cumulative explained variance')
                    plt.ylabel('Explained variance ratio')
                    plt.xlabel('Principal component index')
                    plt.legend(loc='best')
                    plt.tight_layout()
                    dataset_MACCS_PCA= pd.merge(data_MACCS_PCA, input_df, on=smiles_column_name, how='inner')
                    x_label = f'component1 {exp_var_pca[0]}'
                    y_label = f'component2 {exp_var_pca[1]}'
                    fig_pca = px.scatter(
                      dataset_MACCS_PCA,
                      x='component1',
                      y='component2',
                      color='Activity Index',
                      color_continuous_scale=palette,
                      title='PCA - MACCS',
                      labels={'component1': f'Component 1 ({exp_var_pca[0]*100:.3}%)', 'component2': f'Component 2 ({exp_var_pca[1]*100:.3}%)'},
                      width=900,
                      height=700)
                    fig_pca = configure_plot_layout(fig_pca, data_frame=dataset_MACCS_PCA)
                    fig_pca.show()

              if t_SNE is True:
                      data_tsne_MACCS = matrix_MACCS.copy()
                      tsne = TSNE(n_components=2, verbose=0, perplexity=perplexity, n_iter=300)
                      tsne_results_MACCS = tsne.fit_transform(data_tsne_MACCS)
                      label =input_df[[ID, smiles_column_name]]
                      label = label.to_numpy()
                      arr = np.concatenate((label, tsne_results_MACCS), axis = 1)
                      tsne_data = pd.DataFrame(data=arr, columns = [ID, smiles_column_name, 'axis 1', 'axis 2'] )
                      all_dataset_tSNE = pd.merge(tsne_data, input_df, on=smiles_column_name, how='inner')

                      fig_tsne_MACCS = px.scatter(
                       all_dataset_tSNE,
                       x='axis 1',
                       y='axis 2',
                       color='Activity Index',
                       color_continuous_scale=palette,
                       title='T-SNE - MACCS',
                       labels={'axis 1': 'Axis 1', 'axis 2': 'Axis 2'},
                       width=900,
                       height=700)
                      fig_tsne_MACCS = configure_plot_layout(fig_tsne_MACCS, data_frame=all_dataset_tSNE)
                      fig_tsne_MACCS.show()

   if ECFP is True:

                matrix_values_ECFP=np.zeros((len(input_df), len(input_df)))

                for i in input_df.index:
                    for j in input_df.index:
                          a=input_df.loc[i].at['Canonical Smiles']
                          b=input_df.loc[j].at['Canonical Smiles']
                          alignment= similarity_calc(a,b, 'tanimoto', fp_type='ECFP')
                          matrix_values_ECFP[i,j]=alignment
                          matrix_ECFP = pd.DataFrame(matrix_values_ECFP, index=input_df[ID], columns=input_df[ID])
                          df_ECFP = pd.DataFrame(matrix_ECFP)

                if vPCA is True:
                      data_ECFP = matrix_ECFP.iloc[:,0:].values
                      pd.DataFrame(data_ECFP)
                      label_ECFP = input_df.iloc[:,0].values
                      pca_ECPF = PCA(n_components=2)
                      pca_results_ECFP = pca_ECPF.fit_transform(data_ECFP)
                      label_ECFP = input_df[[ID, smiles_column_name]]
                      label_ECFP = label_ECFP.to_numpy()
                      arr = np.concatenate((label_ECFP,pca_results_ECFP), axis = 1)
                      data_ECFP_PCA = pd.DataFrame(data=arr, columns = [ID, smiles_column_name, 'component1', 'component2'])
                      sc = StandardScaler()
                      sc.fit(data_ECFP)
                      X_train_std = sc.transform(data_ECFP)
                      pca = PCA()
                      X_train_pca = pca.fit_transform(X_train_std)
                      exp_var_pca = pca.explained_variance_ratio_
                      exp_var_pca
                      cum_sum_eigenvalues = np.cumsum(exp_var_pca)
                      plt.bar(range(0,len(exp_var_pca)), exp_var_pca, alpha=0.5, align='center', label='Individual explained variance')
                      plt.step(range(0,len(cum_sum_eigenvalues)), cum_sum_eigenvalues, where='mid',label='Cumulative explained variance')
                      plt.ylabel('Explained variance ratio')
                      plt.xlabel('Principal component index')
                      plt.legend(loc='best')
                      plt.tight_layout()
                      dataset_ECFP_PCA= pd.merge(data_ECFP_PCA, input_df, on=smiles_column_name, how='inner')
                      x_label = f'component1 {exp_var_pca[0]}'
                      y_label = f'component2 {exp_var_pca[1]}'
                      fig_pca_ECFP = px.scatter(
                       dataset_ECFP_PCA,
                       x='component1',
                       y='component2',
                       color='Activity Index',
                       color_continuous_scale=palette,
                       title='PCA - ECFP',
                       labels={
                          'component1': f'Component 1 ({exp_var_pca[0]*100:.3}%)',
                          'component2': f'Component 2 ({exp_var_pca[1]*100:.3}%)'},
                       width=900,
                       height=700)
                      fig_pca_ECFP = configure_plot_layout(fig_pca_ECFP, data_frame=dataset_ECFP_PCA)
                      fig_pca_ECFP.show()

                if t_SNE is True:
                      data_tsne_ECFP = matrix_ECFP.copy()
                      tsne = TSNE(n_components=2, verbose=0, perplexity=perplexity, n_iter=300)
                      tsne_results_ECFP = tsne.fit_transform(data_tsne_ECFP)
                      label =input_df[[ID, smiles_column_name]]
                      label = label.to_numpy()
                      arr = np.concatenate((label, tsne_results_ECFP), axis = 1)
                      tsne_data_ECFP = pd.DataFrame(data=arr, columns = [ID, smiles_column_name, 'axis 1', 'axis 2'] )
                      dataset_tSNE_ECFP = pd.merge(tsne_data_ECFP, input_df, on=smiles_column_name, how='inner')
                      fig_tsne_ECFP = px.scatter(
                       dataset_tSNE_ECFP,
                       x='axis 1',
                       y='axis 2',
                       color='Activity Index',
                       color_continuous_scale=palette,
                       title='T-SNE - ECFP',
                       labels={'axis 1': 'Axis 1', 'axis 2': 'Axis 2'},
                       width=900,
                       height=700)
                      fig_tsne_ECFP = configure_plot_layout(fig_tsne_ECFP, data_frame=dataset_tSNE_ECFP)
                      fig_tsne_ECFP.show()

   if MD is True:
          smiles_list = input_df[[ID,'Canonical Smiles']]
          descriptors_df = pd.DataFrame({
            "HBA": [Descriptors.NumHAcceptors(y) for y in (Chem.MolFromSmiles(x) for x in smiles_list["Canonical Smiles"])],
            "LogP": [Descriptors.MolLogP(y) for y in (Chem.MolFromSmiles(x) for x in smiles_list["Canonical Smiles"])],
            "TPSA": [Descriptors.TPSA(y) for y in (Chem.MolFromSmiles(x) for x in smiles_list["Canonical Smiles"])],
            "MW": [Descriptors.MolWt(y) for y in (Chem.MolFromSmiles(x) for x in smiles_list["Canonical Smiles"])],
            "HBD": [Descriptors.NumHDonors(y) for y in (Chem.MolFromSmiles(x) for x in smiles_list["Canonical Smiles"])],
            "RB": [Descriptors.NumRotatableBonds(y) for y in (Chem.MolFromSmiles(x) for x in smiles_list["Canonical Smiles"])]
        }, index=smiles_list.index)

          smiles_list = smiles_list.join(descriptors_df)
          descriptors_values = smiles_list.iloc[:,2:8].values
          molecular_descriptors_data_std = StandardScaler().fit_transform(descriptors_values)
          df_MD = pd.DataFrame(molecular_descriptors_data_std)

          if vPCA is True:
              pca = PCA(n_components=2)
              pca_results_MD = pca.fit_transform(molecular_descriptors_data_std)
              label = input_df[[ID, smiles_column_name]]
              label = label.to_numpy()
              arr = np.concatenate((label,pca_results_MD), axis = 1)
              data_MD_PCA = pd.DataFrame(data=arr, columns = [ID, smiles_column_name, 'component1', 'component2'])
              sc = StandardScaler()
              sc.fit(molecular_descriptors_data_std)
              X_train_std = sc.transform(molecular_descriptors_data_std)
              pca = PCA()
              X_train_pca = pca.fit_transform(X_train_std)
              exp_var_pca = pca.explained_variance_ratio_
              exp_var_pca
              cum_sum_eigenvalues = np.cumsum(exp_var_pca)
              plt.bar(range(0,len(exp_var_pca)), exp_var_pca, alpha=0.5, align='center', label='Individual explained variance')
              plt.step(range(0,len(cum_sum_eigenvalues)), cum_sum_eigenvalues, where='mid',label='Cumulative explained variance')
              plt.ylabel('Explained variance ratio')
              plt.xlabel('Principal component index')
              plt.legend(loc='best')
              plt.tight_layout()
              dataset_MD_PCA= pd.merge(data_MD_PCA, input_df, on=smiles_column_name, how='inner')
              x_label = f'component1 {exp_var_pca[0]}'
              y_label = f'component2 {exp_var_pca[1]}'
              fig_pca_MD = px.scatter(
                 dataset_MD_PCA,
                 x='component1',
                 y='component2',
                 color='Activity Index',
                 color_continuous_scale=palette,
                 title='PCA - MD',
                 labels={
                       'component1': f'Component 1 ({exp_var_pca[0]*100:.3}%)',
                       'component2': f'Component 2 ({exp_var_pca[1]*100:.3}%)'},
                 width=900,
                 height=700)

              fig_pca_MD = configure_plot_layout(fig_pca_MD, data_frame=dataset_MD_PCA)
              fig_pca_MD.show()

          if t_SNE is True:
                tsne = TSNE(n_components=2, verbose=0, perplexity=perplexity, n_iter=300)
                tsne_results_MD = tsne.fit_transform(molecular_descriptors_data_std)
                label =input_df[[ID, smiles_column_name]]
                label = label.to_numpy()
                arr = np.concatenate((label, tsne_results_MD), axis = 1)
                tsne_data_MD = pd.DataFrame(data=arr, columns = [ID, smiles_column_name, 'axis 1', 'axis 2'] )
                dataset_tSNE_MD = pd.merge(tsne_data_MD, input_df, on=smiles_column_name, how='inner')
                fig_tsne_MD = px.scatter(
                    dataset_tSNE_MD,
                    x='axis 1',
                    y='axis 2',
                    color='Activity Index',
                    color_continuous_scale=palette,
                    title='T-SNE - MD',
                    labels={'axis 1': 'Axis 1', 'axis 2': 'Axis 2'},
                    width=900,
                    height=700)
                fig_tsne_MD = configure_plot_layout(fig_tsne_MD, data_frame=dataset_tSNE_MD)
                fig_tsne_MD.show()